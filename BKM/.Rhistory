for (j in 1:T){
if (!is.na(x[i,j]) & x[i,j]==0) w[i,j]<-NA
if (is.na(x[i,j]))              w[i,j]<-NA
}
}
## determine times when animals are known to be alive (even though they may not be seen at those times)
k.alive<-matrix(0,N,T)
for (i in 1:N){
lo<-min(which(x[i,]==1))
up<-max(which(x[i,]==1))
if (sum(which(x[i,]==2))>0) up<-max(up,max(which(x[i,]==2))-1)
k.alive[i,lo:up]<-1
}
########################################
### Part II: estimation of the model ###
########################################
## number of intervals used in the approximation
m=40
## define essential range of covariate process used in numerical integration to approximate the likelihood
max.w  <-  round(12/10*max(abs(w)[!is.na(w)])) # essential range upper limit
min.w  <-  round(8/10*min(abs(w)[!is.na(w)]))  # essential range lower limit
K      <-m+1
wb     <- seq(min.w,max.w,length=K)
wgrid  <-(wb[-1]+wb[-K])*0.5
## function that transforms natural (constrained) parameters to working (unconstrained) parameters
n2w<-function(beta,p,lambda,sigma,phi,alpha,mu){
parvect<-c(beta,logit(p),logit(lambda),log(sigma),logit(phi),alpha,mu)
return(parvect)
}
## function that performs the inverse transformation
w2n=function(parvect){
beta   <- parvect[1:2]
p      <- inv.logit(parvect[3])
lambda <- inv.logit(parvect[4])
sigma  <- exp(parvect[5])
phi    <- inv.logit(parvect[6])
alpha  <- parvect[7]
mu     <- parvect[8]
return(list(beta=beta,p=p,lambda=lambda,sigma=sigma,phi=phi,alpha=alpha,mu=mu))
}
## function that computes minus the approximate log likelihood
funmllk<-function(parvect,x){
lpn<-w2n(parvect)
mllk=rep(NA,N)
alp<-lpn$alpha*sin(2*pi*(1:T)/T)
for (i in 1:N){
start<-min(which(k.alive[i,]==1))
delta<-rep(0,m+2)
if (wb[1]<w[i,start]) {
delta[max(which(wb<w[i,start]))]<-1
}
else {
delta[1]<-1
}
foo <- delta
sumfoo<-sum(foo)
lscale<-log(sumfoo)
foo<-foo/sumfoo
for (j in (start+1):T){
if (x[i,j-1]==2) break
gamma   <- matrix(0,m+2,m+2)
gamma[(m+1):(m+2),m+2]<-c(1,1)
P  <- c(rep(lpn$p,m),lpn$lambda,0)
Pc <- c(rep(1-lpn$p,m),1-lpn$lambda,1)
if (x[i,j]==2) {
if (is.na(w[i,j-1]))  gamma[,m+1]<-c(1-inv.logit(lpn$beta[1]+lpn$beta[2]*wgrid),1,0)
if (!is.na(w[i,j-1])) gamma[,m+1]<-c(1-inv.logit(lpn$beta[1]+lpn$beta[2]*rep(w[i,j-1],m)),1,0)
gamma[,-(m+1)]<-matrix(0,m+2,m+1)
}
if (x[i,j]==1) {
gamma   <- matrix(0,m+2,m+2)
if (!is.na(w[i,j])) {
ifelse(wb[1]<w[i,j],ind<-max(which(wb[-K]<w[i,j])),ind<-1)
if (is.na(w[i,j-1]))  gamma[1:m,ind]<-dnorm(w[i,j],lpn$phi*(wgrid-lpn$mu)+lpn$mu+alp[j],lpn$sigma)*inv.logit(lpn$beta[1]+lpn$beta[2]*wgrid)
if (!is.na(w[i,j-1])) gamma[1:m,ind]<-dnorm(w[i,j],lpn$phi*(rep(w[i,j-1]-lpn$mu,m))+lpn$mu+alp[j],lpn$sigma)*inv.logit(lpn$beta[1]+lpn$beta[2]*rep(w[i,j-1],m))
}
}
if (x[i,j]==0) {
if ( is.na(w[i,j-1])) {
for (doo in 1:m){
goo<-pnorm(wb[-1],lpn$phi*(wgrid[doo]-lpn$mu)+lpn$mu+alp[j],lpn$sigma)-pnorm(wb[-K],lpn$phi*(wgrid[doo]-lpn$mu)+lpn$mu+alp[j],lpn$sigma)
surv<-inv.logit(lpn$beta[1]+lpn$beta[2]*wgrid[doo])
gamma[doo,1:m]<-goo/sum(goo)*surv
gamma[doo,m+1]<-1-surv
}
if (k.alive[i,j]==1) {P<-Pc; gamma[1:m,m+1]<-rep(0,m); gamma[1:m,m+2]<-rep(0,m)}
if (k.alive[i,j]==0) {P<-Pc}
}
if (!is.na(w[i,j-1])) {
ifelse(wb[1]<w[i,j-1],ind<-max(which(wb[-K]<w[i,j-1])),ind<-1)
surv<-inv.logit(lpn$beta[1]+lpn$beta[2]*w[i,j-1])
gamma[ind,1:m]<-(pnorm(wb[-1],lpn$phi*(w[i,j-1]-lpn$mu)+lpn$mu+alp[j],lpn$sigma)-pnorm(wb[-K],lpn$phi*(w[i,j-1]-lpn$mu)+lpn$mu+alp[j],lpn$sigma))*surv
gamma[ind,m+1]<-1-surv
if (k.alive[i,j]==1) {P<-Pc; gamma[ind,m+1]<-0; gamma[ind,m+2]<-0}
if (k.alive[i,j]==0) {P<-Pc}
}
}
foo     <- foo%*%gamma*P
sumfoo  <- sum(foo)
lscale  <- lscale+log(sumfoo)
foo     <- foo/sumfoo
}
mllk[i] <- -lscale
}
sum(mllk)
}
## function that runs the numerical minimization of "funmllk" for given starting values
mle<-function(x,beta,p,lambda,sigma,phi,alpha,mu){
parvect<-n2w(beta,p,lambda,sigma,phi,alpha,mu)
mod<-nlm(funmllk,parvect,x=x,print.level=2,stepmax=10,hessian=T,iterlim=10000)
lpn<-w2n(mod$estimate)
return(list(beta=lpn$beta,p=lpn$p,lambda=lpn$lambda,sigma=lpn$sigma,phi=lpn$phi,alpha=lpn$alpha,mu=lpn$mu,mllk=mod$minimum,H=mod$hessian,AIC=mod$minimum*2+2*8))
}
## choose starting values
beta0<-c(-2.5,0.15)
p0<-0.5
lambda0<-0.8
sigma0<-1.5
phi0=0.7
alpha0=1.5
mu0=27
## run numerical maximization and display results
s<-Sys.time()
mod<-mle(x,beta0,p0,lambda0,sigma0,phi0,alpha0,mu0)
solve(mod$H)->hessinv
parvect<-n2w(mod$beta,mod$p,mod$lambda,mod$sigma,mod$phi,mod$alpha,mod$mu)
c1<-parvect[1]+sqrt(hessinv[1,1])*c(qnorm(0.025),0,qnorm(0.975))
c2<-parvect[2]+sqrt(hessinv[2,2])*c(qnorm(0.025),0,qnorm(0.975))
c3<-parvect[3]+sqrt(hessinv[3,3])*c(qnorm(0.025),0,qnorm(0.975))
c4<-parvect[4]+sqrt(hessinv[4,4])*c(qnorm(0.025),0,qnorm(0.975))
c5<-parvect[5]+sqrt(hessinv[5,5])*c(qnorm(0.025),0,qnorm(0.975))
c6<-parvect[6]+sqrt(hessinv[6,6])*c(qnorm(0.025),0,qnorm(0.975))
c7<-parvect[7]+sqrt(hessinv[7,7])*c(qnorm(0.025),0,qnorm(0.975))
c8<-parvect[8]+sqrt(hessinv[8,8])*c(qnorm(0.025),0,qnorm(0.975))
matrix(round(c(c1,c2,inv.logit(c3),inv.logit(c4),exp(c5),inv.logit(c6),c7,c8),3),
ncol=3,byrow=T,dimnames=list(c("beta_1","beta_2","p","lambda","sigma","phi","alpha","mu"),c("lower CI bound", "estimate", "upper CI bound")))
Sys.time()-s
## Web Appendix A
## This code involves two parts:
## Part I simulates MRR data from the model described in Section 3 of the main manuscript
## Part II fits the correctly specified model (HMM-C) to the simulated data using the HMM-based approach
library(boot)
set.seed(12345)
#################################
### Part I: simulate MRR data ###
#################################
N=500
T=10
x<-matrix(NA,N,T)
w<-matrix(NA,N,T)
alive<-matrix(NA,N,T)
beta<-c(-3,0.2)   # GLIM parameters for survival probability
p<-0.3            # prob. (observed | alive)
lambda<-0.9       # prob. (recovery | dies)
sigma<-1.2        # sd of AR(1)-component in covariate process
phi=0.6           # persistence parameter of AR(1)-component in covariate process
alpha=2           # factor in sine-shaped deterministic trend in covariate process
mu=25
## simulate survival, covariate and observation process
alp<-alpha*sin(2*pi*(1:T)/T)
for (k in 1:N){
boo<-sample(1:(T-1),size=1)
alive[k,boo]<-1
x[k,boo]<-1
w[k,boo]<-rnorm(1,15,2) # initial body mass distribution
for (i in (boo+1):T){
w[k,i]<-phi*(w[k,i-1]-mu)+mu+alp[i]+sigma*rnorm(1)
ifelse(alive[k,i-1]==1,alive[k,i]<-rbinom(1,size=1,prob=inv.logit(beta[1]+beta[2]*w[k,i-1])),alive[k,i]<-0)
if (alive[k,i]==1) {
x[k,i]<-rbinom(1,size=1,prob=p)
}
else {
ifelse(alive[k,i-1]==0,x[k,i]<-0,x[k,i]<-2*rbinom(1,size=1,prob=lambda))
}
}
}
## set missing covariate values equal to NA
for (i in 1:N){
for (j in 1:T){
if (!is.na(x[i,j]) & x[i,j]==0) w[i,j]<-NA
if (is.na(x[i,j]))              w[i,j]<-NA
}
}
## determine times when animals are known to be alive (even though they may not be seen at those times)
k.alive<-matrix(0,N,T)
for (i in 1:N){
lo<-min(which(x[i,]==1))
up<-max(which(x[i,]==1))
if (sum(which(x[i,]==2))>0) up<-max(up,max(which(x[i,]==2))-1)
k.alive[i,lo:up]<-1
}
########################################
### Part II: estimation of the model ###
########################################
## number of intervals used in the approximation
m=40
## define essential range of covariate process used in numerical integration to approximate the likelihood
max.w  <-  round(12/10*max(abs(w)[!is.na(w)])) # essential range upper limit
min.w  <-  round(8/10*min(abs(w)[!is.na(w)]))  # essential range lower limit
K      <-m+1
wb     <- seq(min.w,max.w,length=K)
wgrid  <-(wb[-1]+wb[-K])*0.5
## function that transforms natural (constrained) parameters to working (unconstrained) parameters
n2w<-function(beta,p,lambda,sigma,phi,alpha,mu){
parvect<-c(beta,logit(p),logit(lambda),log(sigma),logit(phi),alpha,mu)
return(parvect)
}
## function that performs the inverse transformation
w2n=function(parvect){
beta   <- parvect[1:2]
p      <- inv.logit(parvect[3])
lambda <- inv.logit(parvect[4])
sigma  <- exp(parvect[5])
phi    <- inv.logit(parvect[6])
alpha  <- parvect[7]
mu     <- parvect[8]
return(list(beta=beta,p=p,lambda=lambda,sigma=sigma,phi=phi,alpha=alpha,mu=mu))
}
## function that computes minus the approximate log likelihood
funmllk<-function(parvect,x){
lpn<-w2n(parvect)
mllk=rep(NA,N)
alp<-lpn$alpha*sin(2*pi*(1:T)/T)
for (i in 1:N){
start<-min(which(k.alive[i,]==1))
delta<-rep(0,m+2)
if (wb[1]<w[i,start]) {
delta[max(which(wb<w[i,start]))]<-1
}
else {
delta[1]<-1
}
foo <- delta
sumfoo<-sum(foo)
lscale<-log(sumfoo)
foo<-foo/sumfoo
for (j in (start+1):T){
if (x[i,j-1]==2) break
gamma   <- matrix(0,m+2,m+2)
gamma[(m+1):(m+2),m+2]<-c(1,1)
P  <- c(rep(lpn$p,m),lpn$lambda,0)
Pc <- c(rep(1-lpn$p,m),1-lpn$lambda,1)
if (x[i,j]==2) {
if (is.na(w[i,j-1]))  gamma[,m+1]<-c(1-inv.logit(lpn$beta[1]+lpn$beta[2]*wgrid),1,0)
if (!is.na(w[i,j-1])) gamma[,m+1]<-c(1-inv.logit(lpn$beta[1]+lpn$beta[2]*rep(w[i,j-1],m)),1,0)
gamma[,-(m+1)]<-matrix(0,m+2,m+1)
}
if (x[i,j]==1) {
gamma   <- matrix(0,m+2,m+2)
if (!is.na(w[i,j])) {
ifelse(wb[1]<w[i,j],ind<-max(which(wb[-K]<w[i,j])),ind<-1)
if (is.na(w[i,j-1]))  gamma[1:m,ind]<-dnorm(w[i,j],lpn$phi*(wgrid-lpn$mu)+lpn$mu+alp[j],lpn$sigma)*inv.logit(lpn$beta[1]+lpn$beta[2]*wgrid)
if (!is.na(w[i,j-1])) gamma[1:m,ind]<-dnorm(w[i,j],lpn$phi*(rep(w[i,j-1]-lpn$mu,m))+lpn$mu+alp[j],lpn$sigma)*inv.logit(lpn$beta[1]+lpn$beta[2]*rep(w[i,j-1],m))
}
}
if (x[i,j]==0) {
if ( is.na(w[i,j-1])) {
for (doo in 1:m){
goo<-pnorm(wb[-1],lpn$phi*(wgrid[doo]-lpn$mu)+lpn$mu+alp[j],lpn$sigma)-pnorm(wb[-K],lpn$phi*(wgrid[doo]-lpn$mu)+lpn$mu+alp[j],lpn$sigma)
surv<-inv.logit(lpn$beta[1]+lpn$beta[2]*wgrid[doo])
gamma[doo,1:m]<-goo/sum(goo)*surv
gamma[doo,m+1]<-1-surv
}
if (k.alive[i,j]==1) {P<-Pc; gamma[1:m,m+1]<-rep(0,m); gamma[1:m,m+2]<-rep(0,m)}
if (k.alive[i,j]==0) {P<-Pc}
}
if (!is.na(w[i,j-1])) {
ifelse(wb[1]<w[i,j-1],ind<-max(which(wb[-K]<w[i,j-1])),ind<-1)
surv<-inv.logit(lpn$beta[1]+lpn$beta[2]*w[i,j-1])
gamma[ind,1:m]<-(pnorm(wb[-1],lpn$phi*(w[i,j-1]-lpn$mu)+lpn$mu+alp[j],lpn$sigma)-pnorm(wb[-K],lpn$phi*(w[i,j-1]-lpn$mu)+lpn$mu+alp[j],lpn$sigma))*surv
gamma[ind,m+1]<-1-surv
if (k.alive[i,j]==1) {P<-Pc; gamma[ind,m+1]<-0; gamma[ind,m+2]<-0}
if (k.alive[i,j]==0) {P<-Pc}
}
}
foo     <- foo%*%gamma*P
sumfoo  <- sum(foo)
lscale  <- lscale+log(sumfoo)
foo     <- foo/sumfoo
}
mllk[i] <- -lscale
}
sum(mllk)
}
## function that runs the numerical minimization of "funmllk" for given starting values
mle<-function(x,beta,p,lambda,sigma,phi,alpha,mu){
parvect<-n2w(beta,p,lambda,sigma,phi,alpha,mu)
mod<-nlm(funmllk,parvect,x=x,print.level=2,stepmax=10,hessian=T,iterlim=10000)
lpn<-w2n(mod$estimate)
return(list(beta=lpn$beta,p=lpn$p,lambda=lpn$lambda,sigma=lpn$sigma,phi=lpn$phi,alpha=lpn$alpha,mu=lpn$mu,mllk=mod$minimum,H=mod$hessian,AIC=mod$minimum*2+2*8))
}
## choose starting values
beta0<-c(-2.5,0.15)
p0<-0.5
lambda0<-0.8
sigma0<-1.5
phi0=0.7
alpha0=1.5
mu0=27
## run numerical maximization and display results
s<-Sys.time()
mod<-mle(x,beta0,p0,lambda0,sigma0,phi0,alpha0,mu0)
solve(mod$H)->hessinv
parvect<-n2w(mod$beta,mod$p,mod$lambda,mod$sigma,mod$phi,mod$alpha,mod$mu)
c1<-parvect[1]+sqrt(hessinv[1,1])*c(qnorm(0.025),0,qnorm(0.975))
c2<-parvect[2]+sqrt(hessinv[2,2])*c(qnorm(0.025),0,qnorm(0.975))
c3<-parvect[3]+sqrt(hessinv[3,3])*c(qnorm(0.025),0,qnorm(0.975))
c4<-parvect[4]+sqrt(hessinv[4,4])*c(qnorm(0.025),0,qnorm(0.975))
c5<-parvect[5]+sqrt(hessinv[5,5])*c(qnorm(0.025),0,qnorm(0.975))
c6<-parvect[6]+sqrt(hessinv[6,6])*c(qnorm(0.025),0,qnorm(0.975))
c7<-parvect[7]+sqrt(hessinv[7,7])*c(qnorm(0.025),0,qnorm(0.975))
c8<-parvect[8]+sqrt(hessinv[8,8])*c(qnorm(0.025),0,qnorm(0.975))
matrix(round(c(c1,c2,inv.logit(c3),inv.logit(c4),exp(c5),inv.logit(c6),c7,c8),3),
ncol=3,byrow=T,dimnames=list(c("beta_1","beta_2","p","lambda","sigma","phi","alpha","mu"),c("lower CI bound", "estimate", "upper CI bound")))
Sys.time()-s
?n2w
? n2w
c1
setwd("BKM")
rm(list=ls())
# Load required packages and fix the random seed
library(rjags)
library(coda)
library(lattice)
set.seed(134522)
save_on = FALSE
scaled_on = TRUE
# MCMC details: ####
# ada=1000
# iter=3000
# th=1
# cha=2
ada=100
iter=2000
th=1
cha=3
# Read data
if (scaled_on){
source("BKM_Data_scaled.R")
# Set parameters and inital values
source("BKM_StartingVals_scaled.R")
}else {
source("BKM_Data.R")
# Set parameters and inital values
source("BKM_StartingVals.R")
}
# Compile the model: ####
if (scaled_on){
tstart=proc.time()
mod <- jags.model('BKM_Bugs_scaled.R',data,inits,n.chains=cha,n.adapt=ada)
temp=proc.time()-tstart
time_init <- temp
if (save_on) {
save(mod, time_init, file = "BKM_model_scaled.RData")
}
}else {
tstart=proc.time()
mod <- jags.model('BKM_Bugs.R',data,inits,n.chains=cha,n.adapt=ada)
temp=proc.time()-tstart
time_init <- temp # ada = 100 --> PC: 1.23; ada = 1000 --> PC: 6.29
if (save_on) {
save(mod, time_init, file = "BKM_model.RData")
}
}
save_on = TRUE
if (save_on) {
save(mod, time_init, file = "BKM_model_scaled.RData")
}
# Run the MCMC: ####
tstart=proc.time()
output1 <- coda.samples(mod,params,n.iter=iter,thin=th)
temp=proc.time()-tstart
time_sample <- temp # PC org:   5.23
if (save_on) {
if (scaled_on){
save(output1, time_sample, file = paste("BKM_iter",toString(iter),"_ada",toString(ada),"_scaled.RData",sep=""))
}else {
save(output1, time_sample, file = paste("BKM_iter",toString(iter),"_ada",toString(ada),".RData",sep=""))
}
}
mat1 = as.matrix(output1[1])
mat2 = as.matrix(output1[2])
mat3 = as.matrix(output1[3])
par(mfrow=c(2,3))
plot(mat1[,"sigy"], type="l", xlab ="", ylab="", sub="sigy")
plot(mat1[,"alphar"], type="l", xlab ="", ylab="", sub="alpha r")
plot(mat1[,"betar"], type="l", xlab ="", ylab="", sub="beta r")
plot(mat1[,"Na[13]"], type="l", xlab ="", ylab="", sub="Na[13]")
plot(mat1[,"Na[23]"], type="l", xlab ="", ylab="", sub="Na[23]")
plot(mat1[,"Na[33]"], type="l", xlab ="", ylab="", sub="Na[33]")
par(mfrow=c(2,3))
plot(mat2[,"sigy"], type="l", xlab ="", ylab="", sub="sigy")
plot(mat2[,"alphar"], type="l", xlab ="", ylab="", sub="alpha r")
plot(mat2[,"betar"], type="l", xlab ="", ylab="", sub="beta r")
plot(mat2[,"Na[13]"], type="l", xlab ="", ylab="", sub="Na[13]")
plot(mat2[,"Na[23]"], type="l", xlab ="", ylab="", sub="Na[23]")
plot(mat2[,"Na[33]"], type="l", xlab ="", ylab="", sub="Na[33]")
par(mfrow=c(4,2))
acf(output1[[1]][,"Na[3]"], main="Na[3], Chain 1")
acf(output1[[2]][,"Na[3]"], main="Na[3], Chain 2")
acf(output1[[1]][,"Na[13]"], main="Na[13], Chain 1")
acf(output1[[2]][,"Na[13]"], main="Na[13], Chain 2")
acf(output1[[1]][,"Na[23]"], main="Na[23], Chain 1")
acf(output1[[2]][,"Na[23]"], main="Na[23], Chain 2")
acf(output1[[1]][,"Na[33]"], main="Na[33], Chain 1")
acf(output1[[2]][,"Na[33]"], main="Na[33], Chain 2")
par(mfrow=c(4,2))
acf(output1[[1]][,"Na[3]"], main="Na[3], Chain 1")
acf(output1[[2]][,"Na[3]"], main="Na[3], Chain 2")
acf(output1[[1]][,"Na[13]"], main="Na[13], Chain 1")
acf(output1[[2]][,"Na[13]"], main="Na[13], Chain 2")
acf(output1[[1]][,"Na[23]"], main="Na[23], Chain 1")
acf(output1[[2]][,"Na[23]"], main="Na[23], Chain 2")
acf(output1[[1]][,"Na[33]"], main="Na[33], Chain 1")
acf(output1[[2]][,"Na[33]"], main="Na[33], Chain 2")
par(mfrow=c(4,2))
acf(output1[[1]][501:2000,"Na[3]"], main="Na[3], Chain 1")
acf(output1[[2]][501:2000,"Na[3]"], main="Na[3], Chain 2")
acf(output1[[1]][501:2000,"Na[13]"], main="Na[13], Chain 1")
acf(output1[[2]][501:2000,"Na[13]"], main="Na[13], Chain 2")
acf(output1[[1]][501:2000,"Na[23]"], main="Na[23], Chain 1")
acf(output1[[2]][501:2000,"Na[23]"], main="Na[23], Chain 2")
acf(output1[[1]][501:2000,"Na[33]"], main="Na[33], Chain 1")
acf(output1[[2]][501:2000,"Na[33]"], main="Na[33], Chain 2")
par(mfrow=c(4,2))
acf(output1[[1]][501:2000,"alphar"], main="alphar, Chain 1")
acf(output1[[2]][501:2000,"alphar"], main="alphar, Chain 2")
acf(output1[[1]][501:2000,"betar"], main="betar, Chain 1")
acf(output1[[2]][501:2000,"betar"], main="betar, Chain 2")
acf(output1[[1]][501:2000,"alphal"], main="alphal, Chain 1")
acf(output1[[2]][501:2000,"alphal"], main="alphal, Chain 2")
acf(output1[[1]][501:2000,"betal"], main="betal, Chain 1")
acf(output1[[2]][501:2000,"betal"], main="betal, Chain 2")
par(mfrow=c(4,2))
acf(output1[[1]][501:2000,"alpha1"], main="alpha1, Chain 1")
acf(output1[[2]][501:2000,"alpha1"], main="alpha1, Chain 2")
acf(output1[[1]][501:2000,"beta1"], main="beta1, Chain 1")
acf(output1[[2]][501:2000,"beta1"], main="beta1, Chain 2")
acf(output1[[1]][501:2000,"alphaa"], main="alphaa, Chain 1")
acf(output1[[2]][501:2000,"alphaa"], main="alphaa, Chain 2")
acf(output1[[1]][501:2000,"betaa"], main="betaa, Chain 1")
acf(output1[[2]][501:2000,"betaa"], main="betaa, Chain 2")
# Chain 3
par(mfrow=c(2,3), oma = c(0, 0, 1.5, 0))
plot(mat3[,"sigy"], type="l", xlab ="", ylab="", sub="sigy")
plot(mat3[,"alphar"], type="l", xlab ="", ylab="", sub="alpha r")
plot(mat3[,"betar"], type="l", xlab ="", ylab="", sub="beta r")
plot(mat3[,"Na[13]"], type="l", xlab ="", ylab="", sub="Na[13]")
plot(mat3[,"Na[23]"], type="l", xlab ="", ylab="", sub="Na[23]")
plot(mat3[,"Na[33]"], type="l", xlab ="", ylab="", sub="Na[33]")
# transition probability to N1=20
mtext("Chain 3", outer=TRUE, cex=1)
par(mfrow=c(2,3), oma = c(0, 0, 1.5, 0))
plot(mat2[,"sigy"], type="l", xlab ="", ylab="", sub="sigy")
plot(mat2[,"alphar"], type="l", xlab ="", ylab="", sub="alpha r")
plot(mat2[,"betar"], type="l", xlab ="", ylab="", sub="beta r")
plot(mat2[,"Na[13]"], type="l", xlab ="", ylab="", sub="Na[13]")
plot(mat2[,"Na[23]"], type="l", xlab ="", ylab="", sub="Na[23]")
plot(mat2[,"Na[33]"], type="l", xlab ="", ylab="", sub="Na[33]")
mtext("Chain 2", outer=TRUE, cex=1)
# Trace plots ####
par(mfrow=c(2,3), oma = c(0, 0, 1.5, 0))
plot(mat1[,"sigy"], type="l", xlab ="", ylab="", sub="sigy")
plot(mat1[,"alphar"], type="l", xlab ="", ylab="", sub="alpha r")
plot(mat1[,"betar"], type="l", xlab ="", ylab="", sub="beta r")
plot(mat1[,"Na[13]"], type="l", xlab ="", ylab="", sub="Na[13]")
plot(mat1[,"Na[23]"], type="l", xlab ="", ylab="", sub="Na[23]")
plot(mat1[,"Na[33]"], type="l", xlab ="", ylab="", sub="Na[33]")
mtext("Chain 1", outer=TRUE, cex=1)
Na23 <- round(c(mean(mat2[501:2000,"Na[23]"]),sd(mat2[501:2000,"Na[23]"])),4)
sigy <- round(c(mean(mat2[501:2000,"sigy"]),sd(mat2[501:2000,"sigy"])),4)
# alphas betas  ####
alphar <- round(c(mean(mat2[501:2000,"alphar"]),sd(mat2[501:2000,"alphar"])),4)
betar <- round(c(mean(mat2[501:2000,"betar"]),sd(mat2[501:2000,"betar"])),4)
alphal <- round(c(mean(mat2[501:2000,"alphal"]),sd(mat2[501:2000,"alphal"])),4)
betal <- round(c(mean(mat2[501:2000,"betal"]),sd(mat2[501:2000,"betal"])),4)
alpha1 <- round(c(mean(mat2[501:2000,"alpha1"]),sd(mat2[501:2000,"alpha1"])),4)
beta1 <- round(c(mean(mat2[501:2000,"beta1"]),sd(mat2[501:2000,"beta1"])),4)
alphaa <- round(c(mean(mat2[501:2000,"alphaa"]),sd(mat2[501:2000,"alphaa"])),4)
betaa <- round(c(mean(mat2[501:2000,"betaa"]),sd(mat2[501:2000,"betaa"])),4)
# Nas ####
Na3 <- round(c(mean(mat2[501:2000,"Na[3]"]),sd(mat2[501:2000,"Na[3]"])),4)
Na13 <- round(c(mean(mat2[501:2000,"Na[13]"]),sd(mat2[501:2000,"Na[13]"])),4)
Na23 <- round(c(mean(mat2[501:2000,"Na[23]"]),sd(mat2[501:2000,"Na[23]"])),4)
Na33 <- round(c(mean(mat2[501:2000,"Na[33]"]),sd(mat2[501:2000,"Na[33]"])),4)
DA_scaled_Resultsparams <- matrix(c(sigy,alphar,betar,alphal,betal,alpha1,beta1,alphaa,betaa,Na3,Na13,Na23,Na33),
ncol=8,byrow=T,dimnames=list(c("sigy","alphar","betar","alphal","betal","alpha1","beta1","alphaa","betaa", "Na3","Na13","Na23","Na33"),
c("Mean Full DA", "SD Full DA","Mean Scaled DA", "SD Scaled DA", "Mean Chain1","SD Chain1","Mean Chain2","SD Chain2","Mean Chain3","SD Chain3")))
DA_scaled_Resultsparams
alphar <- round(c(mean(mat2[501:2000,"alphar"]),sd(mat2[501:2000,"alphar"])),4)
betar <- round(c(mean(mat2[501:2000,"betar"]),sd(mat2[501:2000,"betar"])),4)
alphal <- round(c(mean(mat2[501:2000,"alphal"]),sd(mat2[501:2000,"alphal"])),4)
betal <- round(c(mean(mat2[501:2000,"betal"]),sd(mat2[501:2000,"betal"])),4)
alpha1 <- round(c(mean(mat2[501:2000,"alpha1"]),sd(mat2[501:2000,"alpha1"])),4)
beta1 <- round(c(mean(mat2[501:2000,"beta1"]),sd(mat2[501:2000,"beta1"])),4)
alphaa <- round(c(mean(mat2[501:2000,"alphaa"]),sd(mat2[501:2000,"alphaa"])),4)
betaa <- round(c(mean(mat2[501:2000,"betaa"]),sd(mat2[501:2000,"betaa"])),4)
# Nas ####
Na3 <- round(c(mean(mat2[501:2000,"Na[3]"]),sd(mat2[501:2000,"Na[3]"])),4)
Na13 <- round(c(mean(mat2[501:2000,"Na[13]"]),sd(mat2[501:2000,"Na[13]"])),4)
Na23 <- round(c(mean(mat2[501:2000,"Na[23]"]),sd(mat2[501:2000,"Na[23]"])),4)
Na33 <- round(c(mean(mat2[501:2000,"Na[33]"]),sd(mat2[501:2000,"Na[33]"])),4)
DA_scaled_Resultsparams <- matrix(c(sigy,alphar,betar,alphal,betal,alpha1,beta1,alphaa,betaa,Na3,Na13,Na23,Na33),
ncol=2,byrow=T,dimnames=list(c("sigy","alphar","betar","alphal","betal","alpha1","beta1","alphaa","betaa", "Na3","Na13","Na23","Na33"),
c("Mean Full DA", "SD Full DA","Mean Scaled DA", "SD Scaled DA", "Mean Chain1","SD Chain1","Mean Chain2","SD Chain2","Mean Chain3","SD Chain3")))
DA_scaled_Resultsparams <- matrix(c(sigy,alphar,betar,alphal,betal,alpha1,beta1,alphaa,betaa,Na3,Na13,Na23,Na33),
ncol=2,byrow=T,dimnames=list(c("sigy","alphar","betar","alphal","betal","alpha1","beta1","alphaa","betaa", "Na3","Na13","Na23","Na33"),
c("Mean Scaled DA", "SD Scaled DA")))
DA_scaled_Resultsparams
save(DA_scaled_Resultsparams, "BKM_DA_scaled_Resultsparams.R")
save(DA_scaled_Resultsparams, file="BKM_DA_scaled_Resultsparams.R")
save(DA_scaled_Resultsparams, file="BKM_DA_scaled_Resultsparams.RData")
