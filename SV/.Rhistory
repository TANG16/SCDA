c1<-parvect[1]+sqrt(hessinv[1,1])*c(qnorm(0.025),0,qnorm(0.975))
c2<-parvect[2]+sqrt(hessinv[2,2])*c(qnorm(0.025),0,qnorm(0.975))
c3<-parvect[3]+sqrt(hessinv[3,3])*c(qnorm(0.025),0,qnorm(0.975))
c4<-parvect[4]+sqrt(hessinv[4,4])*c(qnorm(0.025),0,qnorm(0.975))
c5<-parvect[5]+sqrt(hessinv[5,5])*c(qnorm(0.025),0,qnorm(0.975))
c6<-parvect[6]+sqrt(hessinv[6,6])*c(qnorm(0.025),0,qnorm(0.975))
c7<-parvect[7]+sqrt(hessinv[7,7])*c(qnorm(0.025),0,qnorm(0.975))
c8<-parvect[8]+sqrt(hessinv[8,8])*c(qnorm(0.025),0,qnorm(0.975))
matrix(round(c(c1,c2,inv.logit(c3),inv.logit(c4),exp(c5),inv.logit(c6),c7,c8),3),
ncol=3,byrow=T,dimnames=list(c("beta_1","beta_2","p","lambda","sigma","phi","alpha","mu"),c("lower CI bound", "estimate", "upper CI bound")))
Sys.time()-s
?n2w
? n2w
c1
load("C:/Users/aga/Dropbox/Research Visit/Ruth King/Codes/BKM/Results/BKM_HMM_try_iter2000_ada100_linux.RData")
time_HMM_sample
29857/3600
Na = round(c(1000, 1000, 1092.23, 1100.01, 1234.32, 1460.85, 1570.38, 1819.79,
1391.27, 1507.60, 1541.44, 1631.21, 1628.60, 1609.33, 1801.68, 1809.08, 1754.74,
1779.48, 1699.13, 1681.39, 1610.46, 1918.45, 1717.07, 1415.69, 1229.02, 1082.02,
1096.61, 1045.84, 1137.03, 981.1, 647.67, 992.65, 968.62, 926.83, 952.96, 865.64)
)
N1 = rep(400,36)
alpha1 = 1
alpha1 = 1
alphaa = 2
alphar = -2
alphal = -4
beta1 =-2
betaa = 0.1
betar = -0.7
betal = -0.3
phi1 = double(T-1)
phia = double(T-1)
lambda = double(T-1)
rho = double(T-1)
invlogit = function(x){exp(x)/(1+exp(x))}
for(t in 1:(T-1)){
ind =  alpha1 + beta1*f[t]
phi1[t] <-exp(ind)/(1+exp(ind)) # corresponds to the year 1963
ind =  alphaa + betaa*f[t]
phia[t] <- invlogit(ind)
# log(rho[t]) <- alphar + betar*t # We assume here that t=1
rho[t] <- exp(alphar + betar*stdT[t]) # We assume here that t=1
# logit(lambda[t]) <- alphal + betal*(t+1)
ind <- alphal + betal*stdT[t]
lambda[t] <- invlogit(ind)
}
dN1 = double(T)
dNa = double(T)
for(t in 1:2){
dN1[t] = dpois(N1[t],200)
dNa[t] = dbinom(Na[t],2000,0.5)
}
T=36
time <- seq(1,T,1)
# standardize the variable
stdT <- (time-mean(time))/sd(time)
f=c(0.1922, 0.3082, 0.3082, -0.9676, 0.5401, 0.3082, 1.1995, 0.1921, -0.8526,
-1.0835, -0.6196, -1.1995, -0.5037, -0.1557, 0.0762, 2.628, -0.3877, -0.968,
1.9318, -0.6196, -0.3877, 1.700, 2.2797, 0.6561, -0.8516, -1.0835, -1.0835,
0.1922, 0.1922, -0.1557, -0.5037, -0.8516, 0.8880, -0.0398, -1.1995, 0)
#
mean(f)
sd(f)
T=36
# covariates
time <- seq(1,T,1)
stdT <- (time-mean(time))/sd(time)
f=c(0.1922, 0.3082, 0.3082, -0.9676, 0.5401, 0.3082, 1.1995, 0.1921, -0.8526,
-1.0835, -0.6196, -1.1995, -0.5037, -0.1557, 0.0762, 2.628, -0.3877, -0.968,
1.9318, -0.6196, -0.3877, 1.700, 2.2797, 0.6561, -0.8516, -1.0835, -1.0835,
0.1922, 0.1922, -0.1557, -0.5037, -0.8516, 0.8880, -0.0398, -1.1995, 0)
alpha1 = 1
alphaa = 2
alphar = -2
alphal = -4
beta1 =-2
betaa = 0.1
betar = -0.7
betal = -0.3
phi1 = double(T-1)
phia = double(T-1)
lambda = double(T-1)
rho = double(T-1)
invlogit = function(x){exp(x)/(1+exp(x))}
for(t in 1:(T-1)){
ind =  alpha1 + beta1*f[t]
phi1[t] <-exp(ind)/(1+exp(ind)) # corresponds to the year 1963
ind =  alphaa + betaa*f[t]
phia[t] <- invlogit(ind)
# log(rho[t]) <- alphar + betar*t # We assume here that t=1
rho[t] <- exp(alphar + betar*stdT[t]) # We assume here that t=1
# logit(lambda[t]) <- alphal + betal*(t+1)
ind <- alphal + betal*stdT[t]
lambda[t] <- invlogit(ind)
}
dN1 = double(T)
dNa = double(T)
for(t in 1:2){
dN1[t] = dpois(N1[t],200)
dNa[t] = dbinom(Na[t],2000,0.5)
}
for(t in 3:T){
bin1 <- N1[t-1]+Na[t-1]
bin2 <- phia[t-1]
po <- Na[t-1]*rho[t-1]*phi1[t-1]
dN1[t] = dpois(N1[t],po)
dNa[t] = dbinom(Na[t],bin1,bin2)
}
# neg bin prior for N1 Na t=1,2
? dpois
plot(dNa)
dNa
log(dNa)
stdT
f
phia
alphaa
betaa
phi1
phi1 = double(T)
phia = double(T)
lambda = double(T)
rho = double(T)
invlogit = function(x){exp(x)/(1+exp(x))}
for(t in 1:(T)){
ind =  alpha1 + beta1*f[t]
phi1[t] <-exp(ind)/(1+exp(ind)) # corresponds to the year 1963
ind =  alphaa + betaa*f[t]
phia[t] <- invlogit(ind)
# log(rho[t]) <- alphar + betar*t # We assume here that t=1
rho[t] <- exp(alphar + betar*stdT[t]) # We assume here that t=1
# logit(lambda[t]) <- alphal + betal*(t+1)
ind <- alphal + betal*stdT[t]
lambda[t] <- invlogit(ind)
}
phi1
rho
lambda
phia
lambda
phi1
phia
sum(log(dNa))
dN1
sum(log(dN1))
dN1>0
sum(log(dN1(dN1>0)))
sum(log(dN1[dN1>0])))
sum(log(dN1[dN1>0]))
which(dN1==0)
ind= which(dN1==0)
ind
dote=function(x,y) points(x,y,col="gold",pch=19,cex=.4)
mote=function(x,y,z,w) lines(c(x,z),c(y,w),col="gold",lwd=.5)
cst=dbeta(.5,.5,.5)*.5 #normalising constant
#inverting f(x)=d, 2nd degree equation
hitden=function(d) .5+.5*sqrt(1-4*( cst/ max(d,dbeta(.5,.5,.5)))^2)*c(-1,1)
#output
curve(dbeta(x,.5,.5),0,1,ylab="density",lwd=2,col="steelblue",n=1001)
x=runif(1);u=runif(1)*dbeta(x,.5,.5);dote(x,u)
for (t in 1:100){ #100 slice steps
bo=hitden(u)
nx=sample(c(runif(1,0,bo[1]),runif(1,bo[2],1)),1)
nu=runif(1)*dbeta(nx,.5,.5)
mote(x,u,nx,nu)
x=nx;u=nu;dote(x,u)
}
curve(dbeta(x,.5,.5),0,1,ylab="density",lwd=2,col="steelblue",n=1001)
mote(x,u,nx,nu)
mote=function(x,y,z,w) lines(c(x,z),c(y,w),col="green",lwd=.5)
mote(x,u,nx,nu)
#graphics
dote=function(x,y) points(x,y,col="gold",pch=19,cex=0.4)
mote=function(x,y,z,w) lines(c(x,z),c(y,w),col="green",lwd=.5)
cst=dbeta(0.5,0.5,0.5)*0.5 #normalising constant
#inverting f(x)=d, 2nd degree equation
hitden=function(d) .5+.5*sqrt(1-4*( cst/ max(d,dbeta(0.5,0.5,0.5)))^2)*c(-1,1)
#output
curve(dbeta(x,.5,.5),0,1,ylab="density",lwd=2,col="steelblue",n=1001)
x=runif(1);
u=runif(1)*dbeta(x,0.5,0.5);
dote(x,u)
for (t in 1:100){ #100 slice steps
bo=hitden(u)
nx=sample(c(runif(1,0,bo[1]),runif(1,bo[2],1)),1)
nu=runif(1)*dbeta(nx,0.5,0.5)
mote(x,u,nx,nu)
x=nx;
u=nu;
dote(x,u)
}
#graphics
dote=function(x,y) points(x,y,col="green",pch=19,cex=0.4)
mote=function(x,y,z,w) lines(c(x,z),c(y,w),col="gold",lwd=.5)
cst=dbeta(0.5,0.5,0.5)*0.5 #normalising constant
#inverting f(x)=d, 2nd degree equation
hitden=function(d) .5+.5*sqrt(1-4*( cst/ max(d,dbeta(0.5,0.5,0.5)))^2)*c(-1,1)
#output
curve(dbeta(x,.5,.5),0,1,ylab="density",lwd=2,col="steelblue",n=1001)
x=runif(1);
u=runif(1)*dbeta(x,0.5,0.5);
dote(x,u)
for (t in 1:100){ #100 slice steps
bo=hitden(u)
nx=sample(c(runif(1,0,bo[1]),runif(1,bo[2],1)),1)
nu=runif(1)*dbeta(nx,0.5,0.5)
mote(x,u,nx,nu)
x=nx;
u=nu;
dote(x,u)
}
load("C:/Users/s1691601/Dropbox/Research Visit/Ruth King/Codes/BKM/Results/BKM_HMM_iter2000_ada100_linux_MP.RData")
time_HMM_sample
26035.721 /3600
#graphics
dote=function(x,y) points(x,y,col="green",pch=19,cex=1)
mote=function(x,y,z,w) lines(c(x,z),c(y,w),col="gold",lwd=0.5)
cst=dbeta(0.5,0.5,0.5)*0.5 #normalising constant
#inverting f(x)=d, 2nd degree equation
hitden=function(d) 0.5+0.5*sqrt(1-4*( cst/ max(d,dbeta(0.5,0.5,0.5)))^2)*c(-1,1)
#output
curve(dbeta(x,.5,.5),0,1,ylab="density",lwd=2,col="steelblue",n=1001)
x=runif(1);
u=runif(1)*dbeta(x,0.5,0.5);
dote(x,u)
for (t in 1:100){ #100 slice steps
bo=hitden(u)
nx=sample(c(runif(1,0,bo[1]),runif(1,bo[2],1)),1)
nu=runif(1)*dbeta(nx,0.5,0.5)
mote(x,u,nx,nu)
x=nx;
u=nu;
dote(x,u)
}
help runif
? runif
help sample
m=30
diag(m)
rep(1,m)
? rnorn
? rnorm
m <- 30 #50 100 200
gmax <- 4
phi <- 0.98
sigma <- 0.2
beta <- 0.05
P1 <- (sigma^2)/(1-phi^2)
T <- 1000
h <- rep(NaN,1000)
h[1] <- sqrt(P1)*rnorm(1)
h[1]
h[1] <- sqrt(P1)*rnorm(1)
for (t in c(2:T)){
h[t] = phi*h[t-1] + sigma*rnorm(1)
}
y <- beta*exp(h/2)*rnorm(T)
plot(y,type='l')
K <- m+1
b <- seq(- gmax,gmax,length=K)
bs <- (b[-1]+b[-K])*0.5
bs
b
sey <- beta*exp(bs/2)
Gamma <- matrix(0,m,m)
for (i in 1:m) Gamma[i,] <- diff(pnorm(b,phi*bs[i],sigma))
Gamma
image(c(1:m),c(1:m),Gamma)
apply(Gamma,1,sum)
? apply
Gamma <- Gamma/apply(Gamma,1,sum)
Gamma
image(c(1:m),c(1:m),Gamma)
t(diag(m)-Gamma+1)
foo <- solve(t(diag(m)-Gamma+1),rep(1,m))
foo
t=1
? solve
load("C:/Users/s1691601/Dropbox/Research Visit/Ruth King/Codes/Heron/Results/Heron_HMM_approx_model_ada500_linux_bin169_bin319_unifprior.RData")
m <- 30 #50 100 200
gmax <- 4
phi <- 0.98
sigma <- 0.2
beta <- 0.05
P1 <- (sigma^2)/(1-phi^2)
T <- 1000
h <- rep(NaN,1000)
h[1] <- sqrt(P1)*rnorm(1)
for (t in c(2:T)){
h[t] = phi*h[t-1] + sigma*rnorm(1)
}
y <- beta*exp(h/2)*rnorm(T)
plot(y,type='l')
K <- m+1
b <- seq(- gmax,gmax,length=K) #endpoints
bs <- (b[-1]+b[-K])*0.5 # midpoints
sey <- beta*exp(bs/2) # st.dev. of y in each midpoint
Gamma <- matrix(0,m,m)
for (i in 1:m) Gamma[i,] <- diff(pnorm(b,phi*bs[i],sigma)) #time constant tpm
Gamma
phi
bs
sey
b
bs
sey
i=1
diff(pnorm(b,phi*bs[i],sigma))
diff(pnorm((b-phi*bs[i])/sigma))
bs
phi
diff(pnorm((b-phi*bs[i])/sigma))
Gamma[,1]
Gamma[1,]
t=1
dnorm(y[t],0,sey)
y[1]
dnorm(0.0505,0,sey)
dnorm(   0.050515497452117,0,sey)
Gamma*dnorm(y[t],0,sey)
P <- dnorm(y[t],0,sey)
Gamma*P
dim(Gamma*P)
dim(P)
dim(Gamma)
A=matrix(c(1:9),ncol = 3,nrow=3,byrow = TRUE)
A
B=c(10:10:90)
B
B=seq(10,90,by=10)
B
B=seq(10,300,by=10)
B=seq(10,30,by=10)
m <- 30 #50 100 200
gmax <- 4
phi <- 0.98
sigma <- 0.2
beta <- 0.05
P1 <- (sigma^2)/(1-phi^2)
T <- 1000
h <- rep(NaN,1000)
h[1] <- sqrt(P1)*rnorm(1)
for (t in c(2:T)){
h[t] = phi*h[t-1] + sigma*rnorm(1)
}
y <- beta*exp(h/2)*rnorm(T)
plot(y,type='l')
K <- m+1
b <- seq(- gmax,gmax,length=K) #endpoints
bs <- (b[-1]+b[-K])*0.5 # midpoints
sey <- beta*exp(bs/2) # st.dev. of y in each midpoint
Gamma <- matrix(0,m,m)
for (i in 1:m) Gamma[i,] <- diff(pnorm(b,phi*bs[i],sigma)) #time constant tpm
Gamma <- Gamma/apply(Gamma,1,sum)	 #scale the rows of Gamma to sum up to 1
foo <- solve(t(diag(m)-Gamma+1),rep(1,m)) # compute delta=delta*Gamma, the stationary distribution of the MC
llk <- 0
t=1
P <- dnorm(y[t],0,sey)
P
typeof(P)
typeof(Gamma)
typeof(foo)
foo%*%Gamma*dnorm(y[t],0,sey)
foo
Gamma*dnorm(y[t],0,sey)
size(Gamma*dnorm(y[t],0,sey))
dim(Gamma*dnorm(y[t],0,sey))
A<-matrix(c(1:9),nrow = 3,byrow = TRUE)
B<-c(10,20,30)
A*B
A%*%B
A*t(B)
t(B)*A
B*A
A
B
B<-matrix(c(10,20,30),nrow=3)
A*B
A*t(B)
A*as.vector(B)
B
A*B
A%*%B
Gamma%*%dnorm(y[t],0,sey)
Gamma%*%diag(dnorm(y[t],0,sey))
diag(dnorm(y[t],0,sey))
Gamma%*%diag(dnorm(y[t],0,sey))
Gamma%*%dnorm(y[t],0,sey)
Gamma%*%dnorm(y[t],0,sey)
Gamma*dnorm(y[t],0,sey)
phi
y[1]
foo%*%Gamma*dnorm(y[t],0,sey)
sumfoo
foo
foo <- solve(t(diag(m)-Gamma+1),rep(1,m)) # compute delta=delta*Gamma, the stationary distribution of the MC
t=1
llk <- 0
foo <- foo%*%Gamma*dnorm(y[t],0,sey)
sumfoo <- sum(foo)
sumfoo
foo
plot(foo,type='l')
plot(t(foo),type='l')
plot(t(foo))
llk <- llk+log(sumfoo)
foo <- foo/sumfoo
for (t in 2:length(y)){
# P <- dnorm(y[t],0,sey)
foo <- foo%*%Gamma*dnorm(y[t],0,sey)
sumfoo <- sum(foo)
llk <- llk+log(sumfoo)
foo <- foo/sumfoo
}
llk
foo <- solve(t(diag(m)-Gamma+1),rep(1,m)) # compute delta=delta*Gamma, the stationary distribution of the MC
llk <- 0
for (t in 1:length(y)){
# P <- dnorm(y[t],0,sey)
foo <- foo%*%Gamma*dnorm(y[t],0,sey)
sumfoo <- sum(foo)
llk <- llk+log(sumfoo)
# foo <- foo/sumfoo
}
llk
foo <- solve(t(diag(m)-Gamma+1),rep(1,m)) # compute delta=delta*Gamma, the stationary distribution of the MC
llk <- 0
for (t in 1:10){
# P <- dnorm(y[t],0,sey)
foo <- foo%*%Gamma*dnorm(y[t],0,sey)
sumfoo <- sum(foo)
llk <- llk+log(sumfoo)
# foo <- foo/sumfoo
}
llk
foo <- solve(t(diag(m)-Gamma+1),rep(1,m)) # compute delta=delta*Gamma, the stationary distribution of the MC
llk <- 0
for (t in 1:10){
# P <- dnorm(y[t],0,sey)
foo <- foo%*%Gamma*dnorm(y[t],0,sey)
sumfoo <- sum(foo)
llk <- llk+log(sumfoo)
foo <- foo/sumfoo
}
llk
log(sumfoo)
N_bin = 10 # Number of intervals
# Lower bin values:
qu <- c(0:(N_bin-1))/N_bin
mid <- qu+qu[2]/2
qu
mid
qu[2]
? qnorm
? qpois
library(R.matlab)
install.packages("R.matlab")
library(R.matlab)
data <- readMat('SV_results.mat')
setwd('SV')
data <- readMat('SV_results.mat')
data <- readMat('SV_results.mat')
data_DA <- readMat('SV_DA_IF.mat')
gc()
data_DA <- readMat('SV_DA_IF.mat')
gc()
data_DA <- readMat('SV_DA_IF.mat')
data_DA
data_DA$H.DA.init
H_DA_init <- data_DA$H.DA.init
? effectiveSize
library(coda)
EFF = lapply(H_DA_init,effectiveSize)
H_DA_init <- as.mcmc(data_DA$H.DA.init)
EFF = lapply(H_DA_init,effectiveSize)
EFF = effectiveSize(H_DA_init[,1])
EFF <- vector(100)
EFF <- vector(,100)
EFF
EFF <- rep(NaN,100)
EFF <- rep(NaN,100)
for (i in c(1:100)){
EFF[i] <- effectiveSize(H_DA_init[,i])
}
EFF
IFF <- EFF*M
M = 10000
IFF <- EFF*M
IF_DA_init <- as.mcmc(data_DA$IF.DA[1:100])
IF_DA_init
IFF
IFF <- M/EFF
IFF
ESS_DA_init <- M/IF_DA_init
ESS_DA_init
EFF
data_DA <- readMat('SV_DA_IF.mat')
H_DA_init <- as.mcmc(data_DA$H.DA.init)
IF_DA_init <- as.mcmc(data_DA$IF.DA[1:100])
ESS_DA_init <- M/IF_DA_init
EFF <- rep(NaN,100)
for (i in c(1:100)){
EFF[i] <- effectiveSize(H_DA_init[,i])
}
IFF <- M/EFF
IF_DA_init
IFF
EFF
ESS_DA_init
IFF[1]
